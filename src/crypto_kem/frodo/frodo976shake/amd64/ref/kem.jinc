from Jade require "crypto_kem/frodo/common/amd64/ref/shake128_opt.jinc"
from Jade require "crypto_kem/frodo/common/amd64/ref/shake256_opt.jinc"
from Jade require "crypto_kem/frodo/common/amd64/ref/encode.jinc"
from Jade require "crypto_kem/frodo/common/amd64/ref/noise.jinc"
from Jade require "crypto_kem/frodo/common/amd64/ref/matrix.jinc"
from Jade require "crypto_kem/frodo/common/amd64/ref/matrix_mul_opt.jinc"
from Jade require "crypto_kem/frodo/common/amd64/ref/pack.jinc"
require "./indcpa.jinc"

// coins = s || seed SE || z
inline
fn __frodo_amd64_ref_keypair_derand(
  reg u64 pkp skp,
  #spill_to_mmx reg ptr u8[BYTES_SEC + BYTES_SEED_SE + BYTES_SEED_A] coins) {
    reg u64 i t;

    // seedA || b
    stack u8[BYTES_PK] pk;
    stack u8[BYTES_SEED_A + BYTES_SEED_SE] indcoins;
    stack u8[BYTES_SEC] pkh;

    // S_T
    stack u8[2*NNBAR] sk;

    i = 0;
    while (i < BYTES_SEC/8) {
        t = coins[u64 i];
        [skp + i*8] = t;
        i += 1;
    }

    // copy seedSE
    i = 0;
    while (i < BYTES_SEED_SE/8) {
        t = coins[u64 BYTES_SEC/8 + i];
        indcoins[u64 BYTES_SEED_A/8 + i] = t;
        i += 1;
    }

    () = #spill(pkp, skp, coins);
    indcoins[0:BYTES_SEED_A] = __shake256_seed_A_opt(indcoins[0:BYTES_SEED_A], coins[BYTES_SEC + BYTES_SEED_SE:BYTES_SEED_A]);

    pk, sk = __indcpa_keypair_derand(indcoins);
    pkh = __shake256_pkh_opt(pkh, pk);

    () = #unspill(pkp, skp);

    i = 0;
    while (i < BYTES_PK/8) {
        t = pk[u64 i];
        [skp + BYTES_SEC + i*8] = t;
        i += 1;
    }

    i = 0;
    while (i < 2 * NNBAR / 8) {
        t = sk[u64 i];
        [skp + BYTES_SEC + BYTES_PK + i*8] = t;
        i += 1;
    }

    i = 0;
    while (i < BYTES_PK/8) {
        t = pk[u64 i];
        [pkp + i*8] = t;
        i += 1;
    }

    i = 0;
    while (i < BYTES_SEC/8) {
        t = pkh[u64 i];
        [skp + BYTES_SK - BYTES_SEC + i*8] = t;
        i += 1;
    }
}

inline
fn __frodo_amd64_ref_enc_derand(
  reg u64 ctp ssp pkp,
  #spill_to_mmx reg ptr u8[BYTES_SEC + BYTES_SALT] coins) {
    reg u64 i t;
    inline int k;

    // seedA || b
    #public stack u8[BYTES_PK] pk;

    // c1 || c2 || salt || k
    stack u8[BYTES_CT + BYTES_SEC] ct_k;

    // pkh || u || salt
    stack u8[BYTES_SEC * 2 + BYTES_SALT] pkh_u_salt;
    // seedSE || k
    stack u8[BYTES_SEED_SE + BYTES_SEC] seedSE_k;

    stack u8[BYTES_SEC] ss;

    // gen u || salt
    i = 0;
    while (i < (BYTES_SEC + BYTES_SALT)/8) {
        t = coins[u64 i];
        pkh_u_salt[u64 BYTES_SEC/8 + i] = t;
        i += 1;
    }

    i = 0;
    while (i < BYTES_SALT/8) {
        t = coins[u64 BYTES_SEC/8 + i];
        ct_k[u64 (BYTES_CT - BYTES_SALT)/8 + i] = t;
        i += 1;
    }

    // read pk
    i = 0;
    while (i < BYTES_PK/8) {
        #declassify pk[u64 i] = [pkp + i*8];
        i += 1;
    }

    () = #spill(ctp, ssp, coins);

    // pkh
    pkh_u_salt[0:BYTES_SEC] = __shake256_pkh_opt(pkh_u_salt[0:BYTES_SEC], pk);

    // seedSE || k
    seedSE_k = __shake256_SE_k_opt(seedSE_k, pkh_u_salt);

    () = #unspill(coins);
    ct_k[0:BYTES_CT - BYTES_SALT] = __indcpa_enc_derand(ct_k[0:BYTES_CT - BYTES_SALT], coins[0:BYTES_SEC], pk, seedSE_k[0:BYTES_SEED_SE]);

    // copy k
    i = 0;
    while (i < BYTES_SEC/8) {
        t = seedSE_k[u64 BYTES_SEED_SE/8 + i];
        ct_k[u64 BYTES_CT/8 + i] = t;
        i += 1;
    }

    // ss <- shake(c1 || c2 || salt || k)
    ss = __shake256_ss_opt(ss, ct_k);

    () = #unspill(ctp, ssp);
    i = 0;
    _ = #init_msf();
    while (i < BYTES_CT/8) {
        t = ct_k[u64 i];
        [ctp + i*8] = t;
        i += 1;
    }

    for k = 0 to BYTES_SEC/8 {
        t = ss[u64 k];
        [ssp + 8*k] = t;
    }
}

fn _frodo_amd64_ref_dec(reg u64 ssp ctp skp) {
    #public stack u8[BYTES_PK] pk;
    stack u8[2 * NNBAR] ST;
    stack u8[BYTES_SEC] s;
    stack u8[BYTES_CT + BYTES_SEC] ct_k;
    stack u8[BYTES_CT - BYTES_SALT] ct2;
    stack u8[BYTES_SEC * 2 + BYTES_SALT] pkh_u_salt;
    stack u8[BYTES_SEED_SE + BYTES_SEC] seedSE_k;
    stack u8[BYTES_SEC] ss;

    reg u8 s1;
    reg u64 i t;

    ctp = ctp;
    skp = skp;
    ssp = ssp;

    // copy pkh
    i = 0;
    while (i < BYTES_SEC/8) {
        t = [skp + BYTES_SK - BYTES_SEC + i*8];
        pkh_u_salt[u64 i] = t;
        i += 1;
    }

    // read ct
    i = 0;
    while (i < BYTES_CT/8) {
        t = [ctp + i*8];
        ct_k[u64 i] = t;
        i += 1;
    }

    i = 0;
    while (i < BYTES_SEC/8) {
        t = [skp + i*8];
        s[u64 i] = t;
        i += 1;
    }

    i = 0;
    while (i < BYTES_PK/8) {
        t = [skp + BYTES_SEC + i*8];
        #declassify pk[u64 i] = t;
        i += 1;
    }

    i = 0;
    while (i < 2 * NNBAR/8) {
        t = [skp + BYTES_SEC + BYTES_PK + i*8];
        ST[u64 i] = t;
        i += 1;
    }

    // copy salt
    i = 0;
    while (i < BYTES_SALT/8) {
        t = ct_k[u64 (BYTES_CT - BYTES_SALT)/8 + i];
        pkh_u_salt[u64 (BYTES_SEC * 2)/8 + i] = t;
        i += 1;
    }

    pkh_u_salt[BYTES_SEC:BYTES_SEC] = __indcpa_dec(pkh_u_salt[BYTES_SEC:BYTES_SEC], ct_k[0:BYTES_CT - BYTES_SALT], ST);

    () = #spill(ssp);
    seedSE_k = __shake256_SE_k_opt(seedSE_k, pkh_u_salt);
    ct2 = __indcpa_enc_derand(ct2, pkh_u_salt[BYTES_SEC:BYTES_SEC], pk, seedSE_k[0:BYTES_SEED_SE]);

    s1 = __ct_verify(ct_k[0:BYTES_CT - BYTES_SALT], ct2);

    ct_k[BYTES_CT:BYTES_SEC] = __ct_select(ct_k[BYTES_CT:BYTES_SEC], seedSE_k[BYTES_SEED_SE:BYTES_SEC], s, s1);

    ss = __shake256_ss_opt(ss, ct_k);

    _ = #init_msf();
    () = #unspill(ssp);
    i = 0;
    while (i < BYTES_SEC/8) {
        t = ss[u64 i];
        [ssp + i*8] = t;
        i += 1;
    }
}

fn _frodo_amd64_ref_keypair(reg u64 pkp skp) {
    #public stack u8[BYTES_SEED_A + BYTES_SEED_SE + BYTES_SEC] coins;

    pkp = pkp;
    skp = skp;

    #declassify coins = #randombytes(coins);

    __frodo_amd64_ref_keypair_derand(pkp, skp, coins);
}

fn _frodo_amd64_ref_keypair_derand(reg u64 pkp skp coinsp) {
    #public stack u8[BYTES_SEED_A + BYTES_SEED_SE + BYTES_SEC] coins;
    reg u64 i;

    pkp = pkp;
    skp = skp;

    i = 0;
    while (i < BYTES_SEED_A + BYTES_SEED_SE + BYTES_SEC) {
        #declassify coins[(int)i] = (u8)[coinsp + i];
        i += 1;
    }

    __frodo_amd64_ref_keypair_derand(pkp, skp, coins);
}

fn _frodo_amd64_ref_enc_derand(reg u64 ctp ssp pkp coinsp) {
    stack u8[BYTES_SEC + BYTES_SALT] coins;
    reg u64 i; stack u64 s_i;

    pkp = pkp;
    ctp = ctp;
    ssp = ssp;

    i = 0;
    while (i < BYTES_SEC + BYTES_SALT) {
       coins[(int)i] = (u8)[coinsp + i];
       i += 1;
    }
    s_i = i;

    __frodo_amd64_ref_enc_derand(ctp, ssp, pkp, coins);
}

fn _frodo_amd64_ref_enc(reg u64 ctp ssp pkp) {
    stack u8[BYTES_SEC + BYTES_SALT] coins;
    pkp = pkp;
    ctp = ctp;
    ssp = ssp;

    coins = #randombytes(coins);

    __frodo_amd64_ref_enc_derand(ctp, ssp, pkp, coins);
}
