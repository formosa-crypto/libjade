fn __pack_B(reg ptr u8[D * N]out, reg ptr u16[NNBAR] in) -> stack u8[D * N] {
    reg u64 i j;
    inline int k MID TERM Mask;
    reg u64 ac tmp;
    reg u16 acm tm;

    Mask = (1 << D) - 1;
    TERM = (D - 1)/2;
    MID = D - TERM * 2;

    i = 0; j = 0;

    // process 16 * 8 bits at a time
    // process 2 parts: | 4 * D bits | 4 * D bits |
    // separate into: | TERM bytes | 1st half of MID bytes | 2nd half of MID bytes | TERM bytes |
    while (i < NNBAR) {
        ac = 0;
        acm = 0;

        // aggregate 1st half (16 * 4 bits) into 4 * D bits in ac
        for k = 0 to 4 {
            tmp = (64u)in[(int)i + k];
            tmp &= Mask;
            ac <<= D;
            ac |= tmp;
        }

        // aggregate the 1st half of the MID in acm from ac
        for k = 0 to MID {
            tm = ac;
            tm &= 0x0F;
            tm <<= 4 * k;
            acm |= tm;
            ac >>= 4;
        }

        // process the 1st TERM in ac
        for k = 0 to TERM {
            out[(int)j + TERM - 1 - k] = ac;
            ac >>= 8;
        }

        // aggregate 2nd half (16 * 4 bits) into 4 * D bits in ac
        for k = 0 to 4 {
            tmp = (64u)in[(int)i + 4 + k];
            tmp &= Mask;
            ac <<= D;
            ac |= tmp;
        }

        // process the 2nd TERM in ac
        for k = 0 to TERM {
            out[(int)j + D - 1 - k] = ac;
            ac >>= 8;
        }

        // aggregate the 2nd half of the MID in acm from ac
        acm <<= 4 * MID;
        for k = 0 to MID {
            tm = ac;
            tm &= 0x0F;
            tm <<= 4 * k;
            acm |= tm;
            ac >>= 4;
        }

        for k = 0 to MID {
            out[(int)j + TERM + MID - 1 - k] = acm;
            acm >>= 8;
        }

        i += 8;
        j += D;
    }

    return out;
}

fn __unpack_B(reg ptr u16[NNBAR]out, reg ptr u8[D * N]in) -> stack u16[NNBAR] {
    inline int k TERM MID MASK;

    reg u64 i j ac tmp;
    reg u16 acm tm;

    // D = TERM + MID + TERM
    TERM = (D - 1)/2;
    MID = D - TERM * 2;
    MASK = (1 << D) - 1;

    i = 0; j = 0;

    // process D bytes at a time
    // separate processing into: | TERM bytes | MID bytes | TERM bytes |
    // combined 1st half 4 * D bits: | TERM | 1st half of MID |
    // combined 2nd half 4 * D bits: | 2nd half of MID | TERM |
    while (i < D * N) {
        ac = 0;
        acm = 0;

        // accumulate the MID bytes (8/16 for D = 15/16) in acm (u16)
        for k = 0 to MID {
            tm = (16u)in[(int)i + TERM + k];
            acm <<= 8;
            acm |= tm;
        }

        // aggregate 2nd half of MID from acm in ac
        for k = 0 to MID {
            tmp = (64u)acm;
            tmp &= 0x0F;
            tmp <<= 4 * k;
            ac |= tmp;
            acm >>= 4;
        }

        // accumulate 2nd TERM bytes in ac
        for k = 0 to TERM {
            tmp = (64u)in[(int)i + TERM + MID + k];
            ac <<= 8;
            ac |= tmp;
        }

        // result in 4 * D bits in 2nd half of output
        for k = 0 to 4 {
            tm = ac;
            tm &= MASK;
            out[(int)j + 7 - k] = tm;
            ac >>= D;
        }

        // accumulate 1st TERM bytes in ac
        for k = 0 to TERM {
            tmp = (64u)in[(int)i + k];
            ac <<= 8;
            ac |= tmp;
        }

        // aggregate 2nd half of MID from acm to ac
        ac <<= 4 * MID;
        for k = 0 to MID {
            tmp = (64u)acm;
            tmp &= 0x0F;
            tmp <<= 4 * k;
            ac |= tmp;
            acm >>= 4;
        }

        // result in 4 * D bits in 1st half of output
        for k = 0 to 4 {
            // disable implicit scaling for handling little endianess
            tm = ac;
            tm &= MASK;
            out[(int)j + 3 - k] = tm;
            ac >>= D;
        }

        i += D;
        j += 8;
    }

    return out;
}

fn __pack_C(reg ptr u8[D * NBAR]out, reg ptr u16[NBAR * NBAR] in) -> stack u8[D * NBAR] {
    reg u64 i j;
    inline int k MID TERM Mask;
    reg u64 ac tmp;
    reg u16 acm tm;

    Mask = (1 << D) - 1;
    TERM = (D - 1)/2;
    MID = D - TERM * 2;

    i = 0; j = 0;

    // process 16 * 8 bits at a time
    // process 2 parts: | 4 * D bits | 4 * D bits |
    // separate into: | TERM bytes | 1st half of MID bytes | 2nd half of MID bytes | TERM bytes |
    while (i < NBAR * NBAR) {
        ac = 0;
        acm = 0;

        // aggregate 1st half (16 * 4 bits) into 4 * D bits in ac
        for k = 0 to 4 {
            tmp = (64u)in[(int)i + k];
            tmp &= Mask;
            ac <<= D;
            ac |= tmp;
        }

        // aggregate the 1st half of the MID in acm from ac
        for k = 0 to MID {
            tm = ac;
            tm &= 0x0F;
            tm <<= 4 * k;
            acm |= tm;
            ac >>= 4;
        }

        // process the 1st TERM in ac
        for k = 0 to TERM {
            out[(int)j + TERM - 1 - k] = ac;
            ac >>= 8;
        }

        // aggregate 2nd half (16 * 4 bits) into 4 * D bits in ac
        for k = 0 to 4 {
            tmp = (64u)in[(int)i + 4 + k];
            tmp &= Mask;
            ac <<= D;
            ac |= tmp;
        }

        // process the 2nd TERM in ac
        for k = 0 to TERM {
            out[(int)j + D - 1 - k] = ac;
            ac >>= 8;
        }

        // aggregate the 2nd half of the MID in acm from ac
        acm <<= 4 * MID;
        for k = 0 to MID {
            tm = ac;
            tm &= 0x0F;
            tm <<= 4 * k;
            acm |= tm;
            ac >>= 4;
        }

        for k = 0 to MID {
            out[(int)j + TERM + MID - 1 - k] = acm;
            acm >>= 8;
        }

        i += 8;
        j += D;
    }

    return out;
}

fn __unpack_C(reg ptr u16[NBAR * NBAR]out, reg ptr u8[D * NBAR]in) -> stack u16[NBAR * NBAR] {
    inline int k TERM MID MASK;

    reg u64 i j ac tmp;
    reg u16 acm tm;

    // D = TERM + MID + TERM
    TERM = (D - 1)/2;
    MID = D - TERM * 2;
    MASK = (1 << D) - 1;

    i = 0; j = 0;

    // process D bytes each time
    // separate processing into: | TERM bytes | MID bytes | TERM bytes |
    // combined 1st half 4 * D bits: | TERM | 1st half of MID |
    // combined 2nd half 4 * D bits: | 2nd half of MID | TERM |
    while (i < D * NBAR) {
        ac = 0;
        acm = 0;

        // accumulate the MID bytes (8/16 for D = 15/16) in acm (u16)
        for k = 0 to MID {
            tm = (16u)in[(int)i + TERM + k];
            acm <<= 8;
            acm |= tm;
        }

        // aggregate 2nd half of MID from acm in ac
        for k = 0 to MID {
            tmp = (64u)acm;
            tmp &= 0x0F;
            tmp <<= 4 * k;
            ac |= tmp;
            acm >>= 4;
        }

        // accumulate 2nd TERM bytes in ac
        for k = 0 to TERM {
            tmp = (64u)in[(int)i + TERM + MID + k];
            ac <<= 8;
            ac |= tmp;
        }

        // result in 4 * D bits in 2nd half of output
        for k = 0 to 4 {
            tm = ac;
            tm &= MASK;
            out[(int)j + 7 - k] = tm;
            ac >>= D;
        }

        // accumulate 1st TERM bytes in ac
        for k = 0 to TERM {
            tmp = (64u)in[(int)i + k];
            ac <<= 8;
            ac |= tmp;
        }

        // aggregate 2nd half of MID from acm to ac
        ac <<= 4 * MID;
        for k = 0 to MID {
            tmp = (64u)acm;
            tmp &= 0x0F;
            tmp <<= 4 * k;
            ac |= tmp;
            acm >>= 4;
        }

        // result in 4 * D bits in 1st half of output
        for k = 0 to 4 {
            // disable implicit scaling for handling little endianess
            tm = ac;
            tm &= MASK;
            out[(int)j + 3 - k] = tm;
            ac >>= D;
        }

        i += D;
        j += 8;
    }

    return out;
}
