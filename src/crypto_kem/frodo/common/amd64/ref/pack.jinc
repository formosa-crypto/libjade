fn __pack_B(reg ptr u8[D * N]out, reg ptr u16[NNBAR] in) -> stack u8[D * N] {
    reg u64 i j l offset;
    inline int k MID TERM Mask;
    reg u64 ac tmp;
    reg u16 acm tm;

    Mask = (1 << D) - 1;
    TERM = (D - 1)/2;
    MID = D - TERM * 2;

    i = 0; j = 0;

    // process 16 * 8 bits at a time
    // process 2 parts: | 4 * D bits | 4 * D bits |
    // separate into: | TERM bytes | 1st half of MID bytes | 2nd half of MID bytes | TERM bytes |
    while (i < NNBAR) {
        ac = 0;
        acm = 0;

        // aggregate 1st half (16 * 4 bits) into 4 * D bits in ac
        l = 0;
        while (l < 4) {
            offset = #LEA(i + l);
            tmp = (64u)in[offset];
            tmp &= Mask;
            ac <<= D;
            ac |= tmp;

            l += 1;
        }

        // aggregate the 1st half of the MID in acm from ac
        for k = 0 to MID {
            tm = ac;
            tm &= 0x0F;
            tm <<= 4 * k;
            acm |= tm;
            ac >>= 4;
        }

        // process the 1st TERM in ac
        l = 0;
        while (l < TERM) {
            offset = #LEA(j + TERM - 1);
            offset -= l;
            out[offset] = ac;
            ac >>= 8;

            l += 1;
        }

        // aggregate 2nd half (16 * 4 bits) into 4 * D bits in ac
        l = 0;
        while (l < 4) {
            offset = #LEA(i + 4 + l);
            tmp = (64u)in[offset];
            tmp &= Mask;
            ac <<= D;
            ac |= tmp;

            l += 1;
        }

        // process the 2nd TERM in ac
        l = 0;
        while (l < TERM) {
            offset = #LEA(j + D - 1);
            offset -= l;
            out[offset] = ac;
            ac >>= 8;

            l += 1;
        }

        // aggregate the 2nd half of the MID in acm from ac
        acm <<= 4 * MID;
        for k = 0 to MID {
            tm = ac;
            tm &= 0x0F;
            tm <<= 4 * k;
            acm |= tm;
            ac >>= 4;
        }

        l = 0;
        while (l < MID) {
            offset = #LEA(j + TERM + MID - 1);
            offset -= l;
            out[offset] = acm;
            acm >>= 8;

            l += 1;
        }

        i += 8;
        j += D;
    }

    return out;
}

fn __unpack_B(reg ptr u16[NNBAR]out, reg ptr u8[D * N]in) -> stack u16[NNBAR] {
    inline int k TERM MID MASK;

    reg u64 i j l ac tmp offset;
    reg u16 acm tm;

    // D = TERM + MID + TERM
    TERM = (D - 1)/2;
    MID = D - TERM * 2;
    MASK = (1 << D) - 1;

    i = 0; j = 0;

    // process D bytes at a time
    // separate processing into: | TERM bytes | MID bytes | TERM bytes |
    // combined 1st half 4 * D bits: | TERM | 1st half of MID |
    // combined 2nd half 4 * D bits: | 2nd half of MID | TERM |
    while (i < D * N) {
        ac = 0;
        acm = 0;

        // accumulate the MID bytes (8/16 for D = 15/16) in acm (u16)
        l = 0;
        while (l < MID) {
            offset = #LEA(i + TERM + l);
            tm = (16u)in[offset];
            acm <<= 8;
            acm |= tm;

            l += 1;
        }

        // aggregate 2nd half of MID from acm in ac
        for k = 0 to MID {
            tmp = (64u)acm;
            tmp &= 0x0F;
            tmp <<= 4 * k;
            ac |= tmp;
            acm >>= 4;
        }

        // accumulate 2nd TERM bytes in ac
        l = 0;
        while (l < TERM) {
            offset = #LEA(i + TERM + MID + l);
            tmp = (64u)in[offset];
            ac <<= 8;
            ac |= tmp;

            l += 1;
        }

        // result in 4 * D bits in 2nd half of output
        l = 0;
        while (l < 4) {
            tm = ac;
            tm &= MASK;
            offset = #LEA(j + 7);
            offset -= l;
            out[offset] = tm;
            ac >>= D;

            l += 1;
        }

        // accumulate 1st TERM bytes in ac
        l = 0;
        while (l < TERM) {
            offset = #LEA(i + l);
            tmp = (64u)in[offset];
            ac <<= 8;
            ac |= tmp;

            l += 1;
        }

        // aggregate 2nd half of MID from acm to ac
        ac <<= 4 * MID;
        for k = 0 to MID {
            tmp = (64u)acm;
            tmp &= 0x0F;
            tmp <<= 4 * k;
            ac |= tmp;
            acm >>= 4;
        }

        // result in 4 * D bits in 1st half of output
        l = 0;
        while (l < 4) {
            // disable implicit scaling for handling little endianness
            offset = #LEA(j + 3);
            offset -= l;
            tm = ac;
            tm &= MASK;
            out[offset] = tm;
            ac >>= D;

            l += 1;
        }

        i += D;
        j += 8;
    }

    return out;
}

fn __pack_C(reg ptr u8[D * NBAR]out, reg ptr u16[NBAR * NBAR] in) -> stack u8[D * NBAR] {
    reg u64 i j l offset;
    inline int k MID TERM Mask;
    reg u64 ac tmp;
    reg u16 acm tm;

    Mask = (1 << D) - 1;
    TERM = (D - 1)/2;
    MID = D - TERM * 2;

    i = 0; j = 0;

    // process 16 * 8 bits at a time
    // process 2 parts: | 4 * D bits | 4 * D bits |
    // separate into: | TERM bytes | 1st half of MID bytes | 2nd half of MID bytes | TERM bytes |
    while (i < NBAR * NBAR) {
        ac = 0;
        acm = 0;

        // aggregate 1st half (16 * 4 bits) into 4 * D bits in ac
        l = 0;
        while (l < 4) {
            offset = #LEA(i + l);
            tmp = (64u)in[offset];
            tmp &= Mask;
            ac <<= D;
            ac |= tmp;

            l += 1;
        }

        // aggregate the 1st half of the MID in acm from ac
        for k = 0 to MID {
            tm = ac;
            tm &= 0x0F;
            tm <<= 4 * k;
            acm |= tm;
            ac >>= 4;
        }

        // process the 1st TERM in ac
        l = 0;
        while (l < TERM) {
            offset = #LEA(j + TERM - 1);
            offset -= l;
            out[offset] = ac;
            ac >>= 8;

            l += 1;
        }

        // aggregate 2nd half (16 * 4 bits) into 4 * D bits in ac
        l = 0;
        while (l < 4) {
            offset = #LEA(i + 4 + l);
            tmp = (64u)in[offset];
            tmp &= Mask;
            ac <<= D;
            ac |= tmp;

            l += 1;
        }

        // process the 2nd TERM in ac
        l = 0;
        while (l < TERM) {
            offset = #LEA(j + D - 1);
            offset -= l;
            out[offset] = ac;
            ac >>= 8;

            l += 1;
        }

        // aggregate the 2nd half of the MID in acm from ac
        acm <<= 4 * MID;
        for k = 0 to MID {
            tm = ac;
            tm &= 0x0F;
            tm <<= 4 * k;
            acm |= tm;
            ac >>= 4;
        }

        l = 0;
        while (l < MID) {
            offset = #LEA(j + TERM + MID - 1);
            offset -= l;
            out[offset] = acm;
            acm >>= 8;

            l += 1;
        }

        i += 8;
        j += D;
    }

    return out;
}

fn __unpack_C(reg ptr u16[NBAR * NBAR]out, reg ptr u8[D * NBAR]in) -> stack u16[NBAR * NBAR] {
    inline int k TERM MID MASK;

    reg u64 i j l ac tmp offset;
    reg u16 acm tm;

    // D = TERM + MID + TERM
    TERM = (D - 1)/2;
    MID = D - TERM * 2;
    MASK = (1 << D) - 1;

    i = 0; j = 0;

    // process D bytes each time
    // separate processing into: | TERM bytes | MID bytes | TERM bytes |
    // combined 1st half 4 * D bits: | TERM | 1st half of MID |
    // combined 2nd half 4 * D bits: | 2nd half of MID | TERM |
    while (i < D * NBAR) {
        ac = 0;
        acm = 0;

        // accumulate the MID bytes (8/16 for D = 15/16) in acm (u16)
        l = 0;
        while (l < MID) {
            offset = #LEA(i + TERM + l);
            tm = (16u)in[offset];
            acm <<= 8;
            acm |= tm;

            l += 1;
        }

        // aggregate 2nd half of MID from acm in ac
        for k = 0 to MID {
            tmp = (64u)acm;
            tmp &= 0x0F;
            tmp <<= 4 * k;
            ac |= tmp;
            acm >>= 4;
        }

        // accumulate 2nd TERM bytes in ac
        l = 0;
        while (l < TERM) {
            offset = #LEA(i + TERM + MID + l);
            tmp = (64u)in[offset];
            ac <<= 8;
            ac |= tmp;

            l += 1;
        }

        // result in 4 * D bits in 2nd half of output
        l = 0;
        while (l < 4) {
            offset = #LEA(j + 7);
            offset -= l;
            tm = ac;
            tm &= MASK;
            out[offset] = tm;
            ac >>= D;

            l += 1;
        }

        // accumulate 1st TERM bytes in ac
        l = 0;
        while (l < TERM) {
            offset = #LEA(i + l);
            tmp = (64u)in[offset];
            ac <<= 8;
            ac |= tmp;

            l += 1;
        }

        // aggregate 2nd half of MID from acm to ac
        ac <<= 4 * MID;
        for k = 0 to MID {
            tmp = (64u)acm;
            tmp &= 0x0F;
            tmp <<= 4 * k;
            ac |= tmp;
            acm >>= 4;
        }

        // result in 4 * D bits in 1st half of output
        l = 0;
        while (l < 4) {
            // disable implicit scaling for handling little endianness
            offset = #LEA(j + 3);
            offset -= l;
            tm = ac;
            tm &= MASK;
            out[offset] = tm;
            ac >>= D;

            l += 1;
        }

        i += D;
        j += 8;
    }

    return out;
}
