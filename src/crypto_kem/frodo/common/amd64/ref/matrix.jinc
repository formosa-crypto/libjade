from Jade require "crypto_kem/frodo/common/amd64/ref/shake128.jinc"

#[returnaddress="stack"]
fn __AS_plus_E(reg ptr u16[NNBAR] B, reg ptr u8[BYTES_SEED_A]seedA, reg ptr u16[NNBAR] S E) -> stack u16[NNBAR] {
    stack ptr u16[NNBAR] s_B;
    stack u16[N] A_row;
    stack ptr u8[BYTES_SEED_A] s_seedA;
    stack ptr u16[NNBAR] s_S s_E;
    stack u8[2 + BYTES_SEED_A] b;

    reg u64 i j k; stack u64 s_i s_j s_k;
    reg u16 tmp ac;

    s_B = B; s_S = S; s_E = E;

    // copy seedA
    i = 0;
    while (i < BYTES_SEED_A) {
        b[(int)i + 2] = seedA[(int)i];
        i += 1;
    }
    s_seedA = seedA;

    // first set B = E
    B = s_B; E = s_E;

    i = 0;
    while (i < NNBAR) {
       B[(int)i] = E[(int)i];
       i += 1;
    }

    s_B = B; s_E = E; s_i = i;

    // calculate A and B += A * S
    b[u16 0] = 0;
    k = 0;

    while (b[u16 0] < N) {
        s_i = i; s_j = j; s_k = k; s_S = S; s_B = B;
        A_row = __shake128_gen_A(A_row, b);
        i = s_i; j = s_j; k = s_k; S = s_S; B = s_B;

        i = 0;
        while (i < NNBAR) {
            ac = 0;
            j = 0;

            // A_row * S_T_row
            while (j < N) {
                tmp = A_row[(int)j];
                tmp *= S[(int)i];
                ac += tmp;
                j += 1;
                i += 1;
            }

            B[(int)k] += ac;
            k += 1;
        }

        b[u16 0] += 1;
    }
    
    return B;
}

#[returnaddress="stack"]
fn __SA_plus_E(reg ptr u16[NNBAR] B, reg ptr u8[BYTES_SEED_A]seedA, reg ptr u16[NNBAR] S E) -> stack u16[NNBAR] {
    stack ptr u16[NNBAR] s_B;
    stack u16[N] A_row;
    stack ptr u8[BYTES_SEED_A] s_seedA;
    stack ptr u16[NNBAR] s_S s_E;
    stack u8[2 + BYTES_SEED_A] b;

    reg u64 i j k; stack u64 s_i s_j s_k;
    reg u16 tmp s;

    // copy seedA
    i = 0;
    while (i < BYTES_SEED_A) {
        b[(int)i + 2] = seedA[(int)i];
        i += 1;
    }
    s_seedA = seedA;

    i = 0;
    while (i < NNBAR) {
       B[(int)i] = E[(int)i];
       i += 1;
    }
    s_B = B; s_S = S; s_E = E;

    // calculate A and B += S * A
    b[u16 0] = 0;

    while (b[u16 0] < N) {
        s_i = i;
        A_row = __shake128_gen_A(A_row, b);
        i = s_i;

        i = 0;
        while (i < NNBAR) {
            k = s_k; S = s_S;

            k = (64u)b[u16 0];
            k += i;
            s = S[(int)k];

            s_k = k; s_S = S;

            j = s_j; B = s_B;
            j = 0;
            while (j < N) {
                tmp = A_row[(int)j];
                tmp *= s;
                B[(int)i] += tmp;

                j += 1;
                i += 1;
            }
            s_j = j; s_B = B;
        }

        b[u16 0] += 1;
    }

    return B;
}

#[returnaddress="stack"]
fn __SB_plus_E(reg ptr u16[NBAR * NBAR] V, reg ptr u16[NNBAR] S B, reg ptr u16[NBAR * NBAR] E) -> stack u16[NBAR * NBAR] {
    reg u64 i j k ti tj;
    reg u16 tmp;

    i = 0;
    while (i < NBAR * NBAR) {
        V[(int)i] = E[(int)i];
        i += 1;
    }

    i = 0;
    while (i < NBAR) {
        j = 0;
        while (j < NBAR) {
            ti = i * NBAR;
            ti += j;

            k = 0;
            while (k < N) {
                tj = i * N;
                tj += k;
                tmp = S[(int)tj];
                tj = k * NBAR;
                tj += j;
                tmp *= B[(int)tj];

                V[(int)ti] += tmp;
                k += 1;
            }

            V[(int)ti] &= (1 << D) - 1;
            j += 1;
        }
        i += 1;
    }

    return V;
}

fn __matrix_add(reg ptr u16[NBAR * NBAR] a b) -> stack u16[NBAR * NBAR] {
    reg u64 i;
    reg u16 tmp;

    i = 0;
    while (i < NBAR * NBAR) {
        tmp = a[(int)i];
        tmp += b[(int)i];
        tmp &= (1 << D) - 1;
        a[(int)i] = tmp;
        i += 1;
    } 

    return a;
}

#[returnaddress="stack"]
// a = b - a
fn __matrix_sub(reg ptr u16[NBAR * NBAR] a b) -> stack u16[NBAR * NBAR] {
    reg u64 i;
    reg u16 tmp;

    i = 0;
    while (i < NBAR * NBAR) {
        tmp = b[(int)i];
        tmp -= a[(int)i];
        tmp &= (1 << D) - 1;
        a[(int)i] = tmp;
        i += 1;
    }

    return a;
}

#[returnaddress="stack"]
fn __mul_BS(reg ptr u16[NBAR * NBAR] M, reg ptr u16[NNBAR]B S) -> stack u16[NBAR * NBAR] {
    reg u64 i j k ti tj;
    reg u16 tmp;

    i = 0;
    while (i < NBAR) {
        j = 0;
        while (j < NBAR) {
            ti = i * NBAR;
            ti += j;
            M[(int)ti] = 0;

            k = 0;
            while (k < N) {
                tj = i * N;
                tj += k;
                tmp = B[(int)tj];

                tj = j * N;
                tj += k;
                tmp *= S[(int)tj];

                M[(int)ti] += tmp;

                k += 1;
            }
            M[(int)ti] &= (1 << D) - 1;
            j += 1;
        }

        i += 1;
    }

    return M;
}

#[returnaddress="stack"]
fn __ct_verify_NNBAR(reg ptr u16[NNBAR] a b) -> stack u8 {
    reg u64 i;
    reg u16 ac tmp;
    reg u8 r;

    i = 0;
    ac = 0;
    while (i < NNBAR) {
        tmp = a[(int) i];
        tmp ^= b[(int)i];
        ac |= tmp;
        i += 1;
    }

    tmp = ac * -1;
    ac |= tmp;
    ac >>= 15;
    ac *= (-1);

    r = (8u)ac;

    return r;
}

#[returnaddress="stack"]
fn __ct_verify_NBAR2(reg ptr u16[NBAR * NBAR] a b) -> stack u8 {
    reg u64 i;
    reg u16 ac tmp;
    reg u8 r;

    i = 0;
    ac = 0;
    while (i < NBAR * NBAR) {
        tmp = a[(int) i];
        tmp ^= b[(int)i];
        ac |= tmp;
        i += 1;
    }

    tmp = ac * -1;
    ac |= tmp;
    ac >>= 15;
    ac *= (-1);

    r = (8u) ac;

    return r;
}

#[returnaddress="stack"]
fn __ct_select(reg ptr u8[BYTES_SEC] out a b, reg u8 selector) -> stack u8[BYTES_SEC] {
    reg u64 i;

    reg u8 n_selector tmp;

    n_selector = selector;
    n_selector ^= 0xFF;

    i = 0;
    while (i < BYTES_SEC) {
        tmp = a[(int)i];
        tmp &= n_selector;
        out[(int)i] = tmp;

        tmp = b[(int)i];
        tmp &= selector;
        out[(int)i] |= tmp;

        i += 1;
    }

    return out;
}
