from Jade require "common/keccak/keccak1600/amd64/ref1/keccak1600.jinc"

param int SHAKE256_RATE = 136;

#[returnaddress="stack"]
fn __shake256_seed_A(reg ptr u8[BYTES_SEED_A] out, reg const ptr u8[BYTES_SEED_A] in) -> stack u8[BYTES_SEED_A]
{
  stack ptr u8[BYTES_SEED_A] s_out;
  stack u64[25] s_state;
  reg ptr u64[25] state;
  reg u8 c;
  reg u64 i; stack u64 s_i;
  inline int INLEN OUTLEN;

  INLEN = BYTES_SEED_A; OUTLEN = BYTES_SEED_A;

  s_out = out;

  state = s_state;
  state =  __keccak_init_ref1(state);

  i = 0;
  while (i < INLEN) {
    c = in[(int) i];
    state[u8 (int) i] ^= c;
    i += 1;
  }
  state[u8 (int) i] ^= 0x1f;
  state[u8 SHAKE256_RATE-1] ^= 0x80;

  s_i = i;

  state = _keccakf1600_ref1(state);

  out = s_out;

  i = s_i;
  i = 0;
  while (i < OUTLEN) {
    out[(int) i] = state[u8 (int) i];
    i += 1;
  }

  return out;
}

#[returnaddress="stack"]
fn __shake256_r(reg ptr u8[4 * NNBAR] out, reg const ptr u8[1 + BYTES_SEED_SE] in) -> stack u8[4 * NNBAR]
{
  stack ptr u8[4 * NNBAR] s_out;
  stack u64[25] s_state;
  reg ptr u64[25] state;
  reg u8 c;
  inline int INLEN OUTLEN OUTRND;
  reg u64 i j;
  stack u64 s_i s_j;

  INLEN = 1 + BYTES_SEED_SE;
  OUTLEN = 4 * NNBAR;
  OUTRND = OUTLEN / SHAKE256_RATE;

  s_out = out;

  state = s_state;
  state =  __keccak_init_ref1(state);

  i = 0;
  while (i < INLEN) {
    c = in[(int) i];
    state[u8 (int) i] ^= c;
    i += 1;
  }

  state[u8 INLEN] ^= 0x1f;
  state[u8 SHAKE256_RATE-1] ^= 0x80;

  i = 0;
  while (i < OUTRND * SHAKE256_RATE) {
    s_i = i; s_j = j; s_out = out;

    state = _keccakf1600_ref1(state);

    out = s_out; i = s_i; j = s_j;
    j = 0;

    while (j < SHAKE256_RATE) {
      out[(int)i] = state[u8 (int)j];
      j += 1;
      i += 1;
    }
  }

  s_i = i; s_j = j; s_out = out;

  state = _keccakf1600_ref1(state);

  out = s_out; i = s_i; j = s_j;
  j = 0;

  while (i < OUTLEN) {
    out[(int) i] = state[u8 (int) j];
    j += 1;
    i += 1;
  }

  return out;
}

#[returnaddress="stack"]
fn __shake256_pkh(reg ptr u8[BYTES_SEC] out, reg const ptr u8[BYTES_PK] in) -> stack u8[BYTES_SEC]
{
  stack ptr u8[BYTES_SEC] s_out;
  stack ptr u8[BYTES_PK] s_in;
  stack u64[25] s_state;
  reg ptr u64[25] state;
  reg u8 c;
  reg u64 i j; stack u64 s_i s_j;
  inline int INLEN OUTLEN INRND;

  INLEN = BYTES_PK; OUTLEN = BYTES_SEC;
  INRND = INLEN / SHAKE256_RATE;
  s_out = out;
  s_in = in;

  state = s_state;
  state =  __keccak_init_ref1(state);

  i = 0;
  while (i < INRND * SHAKE256_RATE) {
    in = s_in;
    j = 0;
    while (j < SHAKE256_RATE) {
      c = in[(int)i];
      state[u8 (int)j] ^= c;

      i += 1;
      j += 1;
    }

    s_in = in; s_i = i; s_j = j;
    state = _keccakf1600_ref1(state);
    i = s_i; j = s_j;
  }

  in = s_in;
  j = 0;
  while (i < INLEN) {
      c = in[(int)i];
      state[u8 (int)j] ^= c;
      i += 1;
      j += 1;
  }

  state[u8 INLEN - INRND * SHAKE256_RATE] ^= 0x1f;
  state[u8 SHAKE256_RATE-1] ^= 0x80;

  s_in = in; s_i = i; s_j = j;

  state = _keccakf1600_ref1(state);

  out = s_out; i = s_i;

  i = 0;
  while (i < OUTLEN) {
    out[(int) i] = state[u8 (int) i];
    i += 1;
  }

  return out;
}

#[returnaddress="stack"]
fn __shake256_SE_k(reg ptr u8[BYTES_SEED_SE + BYTES_SEC] out, reg const ptr u8[2 * BYTES_SEC + BYTES_SALT] in) -> stack u8[BYTES_SEED_SE + BYTES_SEC] {
  stack ptr u8[BYTES_SEED_SE + BYTES_SEC] s_out;
  stack ptr u8[2 * BYTES_SEC + BYTES_SALT] s_in;
  stack u64[25] s_state;
  reg ptr u64[25] state;
  reg u8 c;
  inline int INLEN OUTLEN;
  reg u64 i; stack u64 s_i;

  INLEN = 2 * BYTES_SEC + BYTES_SALT;
  OUTLEN = BYTES_SEED_SE + BYTES_SEC;

  s_out = out; s_in = in;

  state = s_state;
  state =  __keccak_init_ref1(state);

  in = s_in;
  i = 0;
  while (i < INLEN) {
    c = in[(int) i];
    state[u8 (int) i] ^= c;
    i += 1;
  }

  state[u8 INLEN] ^= 0x1f;
  state[u8 SHAKE256_RATE-1] ^= 0x80;

  s_in = in; s_i = i;

  state = _keccakf1600_ref1(state);

  out = s_out; i = s_i;
  i = 0;

  while (i < OUTLEN) {
    out[(int) i] = state[u8 (int) i];
    i += 1;
  }

  return out;
}


#[returnaddress="stack"]
fn __shake256_encap_r(reg ptr u8[2 * (2 * NNBAR + NBAR * NBAR)] out, reg const ptr u8[1 + BYTES_SEED_SE] in) -> stack u8[2 * (2 * NNBAR + NBAR * NBAR)] {
  stack ptr u8[2 * (2 * NNBAR + NBAR * NBAR)] s_out;
  stack ptr u8[1 + BYTES_SEED_SE] s_in;
  stack u64[25] s_state;
  reg ptr u64[25] state;
  reg u8 c;
  inline int INLEN OUTLEN OUTRND;
  reg u64 i j; stack u64 s_i s_j;

  INLEN = 1 + BYTES_SEED_SE;
  OUTLEN = 2 * (2 * NNBAR + NBAR * NBAR);
  OUTRND = OUTLEN / SHAKE256_RATE;

  s_out = out;

  state = s_state;
  state =  __keccak_init_ref1(state);

  i = 0;
  while (i < INLEN) {
    c = in[(int)i];
    state[u8 (int)i] ^= c;
    i += 1;
  }

  state[u8 INLEN] ^= 0x1f;
  state[u8 SHAKE256_RATE-1] ^= 0x80;

  s_in = in;

  i = 0;
  while (i < OUTRND * SHAKE256_RATE) {
    s_out = out; s_i = i; s_j = j;

    state = _keccakf1600_ref1(state);

    out = s_out; i = s_i; j = s_j;
    j = 0;
    while (j < SHAKE256_RATE) {
      out[(int)i] = state[u8 (int)j];
      i += 1;
      j += 1;
    }
  }

  s_out = out; s_i = i; s_j = j;
  state = _keccakf1600_ref1(state);
  out = s_out; i = s_i; j = s_j;

  j = 0;
  while (i < OUTLEN) {
    out[(int) i] = state[u8 (int)j];
    i += 1;
    j += 1;
  }

  return out;
}

#[returnaddress="stack"]
fn __shake256_ss(reg ptr u8[BYTES_SEC] out, reg const ptr u8[BYTES_CT + BYTES_SEC] in) -> stack u8[BYTES_SEC]
{
  stack ptr u8[BYTES_SEC] s_out;
  stack ptr u8[BYTES_CT + BYTES_SEC] s_in;
  stack u64[25] s_state;
  reg ptr u64[25] state;
  reg u8 c;
  reg u64 i j; stack u64 s_i s_j;
  inline int INLEN OUTLEN INRND;

  INLEN = BYTES_CT + BYTES_SEC;
  OUTLEN = BYTES_SEC;
  INRND = INLEN / SHAKE256_RATE;

  s_out = out; s_in = in;

  state = s_state;
  state =  __keccak_init_ref1(state);

  i = 0;
  while (i < INRND * SHAKE256_RATE) {
    in = s_in;
    j = 0;
    while (j < SHAKE256_RATE) {
      c = in[(int)i];
      state[u8 (int)j] ^= c;

      i += 1;
      j += 1;
    }

    s_in = in; s_i = i; s_j = j;
    state = _keccakf1600_ref1(state);
    i = s_i; j = s_j;
  }

  in = s_in;
  j = 0;
  while (i < INLEN) {
      c = in[(int)i];
      state[u8 (int)j] ^= c;
      i += 1;
      j += 1;
  }
  s_in = in; s_i = i; s_j = j;

  state[u8 INLEN - INRND * SHAKE256_RATE] ^= 0x1f;
  state[u8 SHAKE256_RATE-1] ^= 0x80;

  state = _keccakf1600_ref1(state);

  out = s_out; i = s_i;

  i = 0;
  while (i < OUTLEN) {
    out[(int)i] = state[u8 (int)i];
    i += 1;
  }

  return out;
}
