
require "sha256_globals.jinc"

inline fn __initH_ref(reg ptr u32[8] H) -> reg ptr u32[8]
{
  inline int i;
  reg ptr u32[8] H0;
  reg u32 t;

  H0 = SHA256_H0;

  for i=0 to 8
  { t = H0[i];
    H[i] = t; }

  return H;
}

inline fn __load_H_ref(reg ptr u32[8] H) -> reg u32, reg u32, reg u32, reg u32,
                                            reg u32, reg u32, reg u32, reg u32
{
  reg u32 a b c d e f g h;

  a = H[0];
  b = H[1];
  c = H[2];
  d = H[3];
  e = H[4];
  f = H[5];
  g = H[6];
  h = H[7];

  return a, b, c, d, e, f, g, h;
}

inline fn __store_H_ref(reg ptr u32[8] H, reg u32 a b c d e f g h) -> reg ptr u32[8]
{
  H[0] = a;
  H[1] = b;
  H[2] = c;
  H[3] = d;
  H[4] = e;
  H[5] = f;
  H[6] = g;
  H[7] = h;

  return H;
}

inline fn __store_ref(reg u32 out, reg ptr u32[8] H)
{
  inline int i;
  reg u32 v;

  for i=0 to 8
  { v = H[i];
    v = #REV(v);
    (u32)[out + i*4] = v;
  }
}

inline fn __SHR_ref(reg u32 x, inline int c) -> reg u32
{
  reg u32 r;
  r   = x;
  r >>= c;
  return r;
}

inline fn __ROTR_ref(reg u32 x, inline int c) -> reg u32
{
  reg u32 r;
  r = x;
  r = #ROR(r, c);
  return r;
}

//(x & y) ^ (!x & z)
inline fn __CH_ref(reg u32 x y z) -> reg u32
{
  reg u32 r s;

  r  =  x;
  r &=  y;
  s  =  x;
  s  = !s;
  s &=  z;
  r ^=  s;

  return r;
}

//(x & y) ^ (x & z) ^ (y & z)
inline fn __MAJ_ref(reg u32 x y z) -> reg u32
{
  reg u32 r s;

  r  = x;
  r &= y;
  s  = x;
  s &= z;
  r ^= s;
  s  = y;
  s &= z;
  r ^= s;

  return r;
}

// (x >>> 2) ^ (x >>> 13) ^ (x >>> 22)
inline fn __BSIG0_ref(reg u32 x) -> reg u32
{
  reg u32 r s;

  r  = __ROTR_ref(x, 2);
  s  = __ROTR_ref(x,13);
  r ^= s;
  s  = __ROTR_ref(x,22);
  r ^= s;

  return r;
}

// (x >>> 6) ^ (x >>> 11) ^ (x >>> 25)
inline fn __BSIG1_ref(reg u32 x) -> reg u32
{
  reg u32 r s;

  r  = __ROTR_ref(x, 6);
  s  = __ROTR_ref(x,11);
  r ^= s;
  s  = __ROTR_ref(x,25);
  r ^= s;

  return r;
}

// (x >>> 7) ^ (x >>> 18) ^ (x >> 3)
inline fn __SSIG0_ref(reg u32 x) -> reg u32
{
  reg u32 r s;

  r  = __ROTR_ref(x, 7);
  s  = __ROTR_ref(x,18);
  r ^= s;
  s  = __SHR_ref(x,3);
  r ^= s;

  return r;
}

// (x >>> 17) ^ (x >>> 19) ^ (x >> 10)
inline fn __SSIG1_ref(reg u32 x) -> reg u32
{
  reg u32 r s;

  r  = __ROTR_ref(x,17);
  s  = __ROTR_ref(x,19);
  r ^= s;
  s  = __SHR_ref(x,10);
  r ^= s;

  return r;
}

// Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(t-15) + W(t-16)
inline fn __Wt_ref(reg ptr u32[64] W, reg u32 t) -> reg ptr u32[64]
{
  reg u32 wt wt2 wt7 wt16 wt15;

                            t -= 2;
  wt2  = W[(int)t]; // -2
  wt   = __SSIG1_ref(wt2);  t -= 5;
  wt7  = W[(int)t]; // -7
  wt  += wt7;               t -= 8;
  wt15 = W[(int)t]; // -15
  wt15 = __SSIG0_ref(wt15);
  wt  += wt15;              t -= 1;
  wt16 = W[(int)t]; // -16
  wt  += wt16;
                            t += 16;
  W[(int)t] = wt;

  return W;
}

#[returnaddress="stack"]
fn _blocks_inner(reg ptr u32[64] W, reg ptr u32[8] H) -> reg ptr u32[64], reg ptr u32[8]
{
  reg u32 a b c d e f g h r T1 T2 Kt Wt i t;
  stack u32 ts ds hs;

  reg ptr u32[64] K;
  K = SHA256_K;

  i = 16;
  while(i < 64)
  { W = __Wt_ref(W, i);
    i += 1;
  }

  a, b, c, d, e, f, g, h = __load_H_ref(H);
  ds = d;
  hs = h;

  t = 0;
  while(t < 64)
  {
    ts = t;

    //T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt
    r   = __BSIG1_ref(e);
    T1  = hs;
    T1 += r;
    r   = __CH_ref(e,f,g);
    T1 += r;

    Kt = K[(int)t];
    T1 += Kt;

    Wt = W[(int)t];
    T1 += Wt;

    //T2 = BSIG0(a) + MAJ(a,b,c)
    T2  = __BSIG0_ref(a);
    r   = __MAJ_ref(a,b,c);
    T2 += r;

    hs = g;
    g  = f;
    f  = e;
    e  = ds;
    e += T1;
    ds = c;
    c  = b;
    b  = a;
    a  = T1;
    a += T2;

    t = ts;
    t += 1;
  }

  d = ds;
  h = hs;

          t = H[0];
  a += t; t = H[1];
  b += t; t = H[2];
  c += t; t = H[3];
  d += t; t = H[4];
  e += t; t = H[5];
  f += t; t = H[6];
  g += t; t = H[7];
  h += t;

  H = __store_H_ref(H,a,b,c,d,e,f,g,h);

  return W, H;
}

inline fn _blocks_0_ref(reg ptr u32[8] H, reg u32 in, reg u32 inlen) -> reg ptr u32[8], reg u32, reg u32
{
  inline int t;
  reg u32 v;
  stack u32 in_s inlen_s;
  stack u32[64] _W;
  reg ptr u32[64] W K;

  W = _W;

  while(inlen >= 64)
  {
    for t=0 to 16
    { v = (u32)[in + t*4];
      v = #REV(v);
      W[t] = v;
    }

    in_s = in;
    inlen_s = inlen;

    W, H = _blocks_inner(W, H);

    in = in_s;
    inlen = inlen_s;

    in += 64;
    inlen -= 64;
  }

  return H, in, inlen;
}

inline fn _blocks_1_ref(reg ptr u32[8] H, reg ptr u32[32] blocks, reg u32 nblocks) -> reg ptr u32[8]
{
  inline int t;
  reg u32 i v oblocks;
  stack u32 i_s nblocks_s;
  stack u32[64] _W;
  reg ptr u32[64] W K;

  W = _W;

  // nblocks can be 1 or 2 => the following loop executes at most 2 times
  // - for the first loop execution: index for blocks is 0; for the second is 16
  // - hence, nblocks << 4 and i += 16
  i = 0;
  nblocks <<= 4;
  nblocks_s = nblocks;

  while(i < nblocks)
  {
    for t=0 to 16
    { v = blocks[(int)i];
      i += 1;
      v = #REV(v);
      W[t] = v;
    }
    i_s = i;

    W, H = _blocks_inner(W, H);

    i = i_s;
    nblocks = nblocks_s;
  }

  return H;
}

inline fn __lastblocks_ref(reg ptr u32[32] blocks, reg u32 in inlen bits) -> stack u32[32], reg u32
{
  reg u32 zero i v j nblocks;

  // Zero-fill the blocks array
  zero = 0;
  i = 0;
  while(i < 32)
  { blocks[(int)i] = zero;
    i += 1;
  }

  // copy in to blocks
  i = 0;
  while(i < inlen)
  { v = (32u)(u8)[in + i];
    blocks[u8 (int)i] = (8u) v;
    i += 1;
  }

  // set first byte after input to 0x80
  v = 0x80;
  blocks[u8 (int)i] = (8u) v;


  // check if one or two blocks are needed
  if(inlen < 56) // 448 / 8 = 56
  { j = (64-4); nblocks = 1; i = 63; }
  else
  { j = (128-4); nblocks = 2; i = 127; }

  while(i >= j)
  { blocks[u8 (int)i] = (8u) bits;
    bits >>= 8;
    i -= 1;
  }

  return blocks, nblocks;
}

inline fn __sha256_ref(reg u32 out in, reg u32 inlen)
{
  stack u32 s_out s_inlen;
  reg u32 bits nblocks;

  stack u32[8] _H;
  reg ptr u32[8] H;
  stack u32[32] _blocks;
  reg ptr u32[32] blocks;

  H = _H;

  s_out = out;
  s_inlen = inlen;

  H = __initH_ref(H);
  H, in, inlen = _blocks_0_ref(H, in, inlen);

  blocks = _blocks;
  bits = s_inlen;
  bits <<= 3;
  blocks, nblocks = __lastblocks_ref(blocks, in, inlen, bits);

  H = _blocks_1_ref(H, blocks, nblocks);

  out = s_out;
  __store_ref(out, H);
}

