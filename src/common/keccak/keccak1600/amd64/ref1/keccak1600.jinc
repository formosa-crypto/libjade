param int KECCAK_ROUNDS=24;

require "keccakf1600.jinc"

inline fn __keccak_init_ref1(#msf reg u64 ms) -> stack u64[25], #msf reg u64
{
  stack u64[25] state;
  reg u64 i t;
  reg bool b;

  _,_,_,_,_, t = #set0();
  i = 0;
  while{
    b = i < 25;
  } (b)
  {
    ms = #set_msf(b, ms);
    state[(int)i] = t;
    i += 1;
  }
  ms = #set_msf(!b, ms);

  return state, ms;
}


inline fn __add_full_block_ref1(
  reg ptr u64[25] state,
  reg u64 in inlen,
  reg u64 rate,
  #msf reg u64 ms
) -> reg ptr u64[25], reg u64, reg u64, #msf reg u64
{
  reg u64 i t rate64;
  reg bool b;

  rate64 = rate;
  rate64 >>= 3;
  i = 0;
  while{
    b =  i < rate64;
  } (b)
  {
    ms = #set_msf(b, ms);
    t = [in + 8*i];
    state[(int)i] ^= t;
    i+=1;
  }
  ms = #set_msf(!b, ms);

  in += rate;
  inlen -= rate;

  return state, in, inlen, ms;
}


// obs: @pre: inlen < rate_in_bytes
inline fn __add_final_block_ref1(
  reg ptr u64[25] state,
  reg     u64 in inlen,
  reg     u8  trail_byte,
  reg     u64 rate,
  #msf reg u64 ms
) -> reg ptr u64[25], #msf reg u64
{
  reg u64 i t inlen8;
  reg u8 c;
  reg bool b;

  inlen8 = inlen;
  inlen8 >>= 3;
  i = 0;
  while{
    b = i < inlen8;
  } (b)
  {
    ms = #set_msf(b, ms);
    t = [in + 8*i];
    state[(int)i] ^= t;
    i += 1;
  }
  ms = #set_msf(!b, ms);

  i <<= 3;
  while{
    b = i < inlen;
  } (b)
  {
    ms = #set_msf(b, ms);
    c = (u8)[in + i];
    state[u8 (int)i] ^= c;
    i += 1;
  }
  ms = #set_msf(!b, ms);

  state[u8 (int)i] ^= trail_byte;

  i = rate;
  i -= 1;
  state[u8 (int)i] ^= 0x80;

  return state, ms;
}


inline fn __absorb_ref1(
  reg ptr u64[25] state,
  reg   u64 in inlen,
  stack u8  s_trail_byte,
  reg   u64 rate, // rate already in bytes -- it is returned bc of spills
  #msf reg u64 ms
) -> reg ptr u64[25], reg u64, #msf reg u64
{
  stack u64 s_in s_inlen s_rate;
  reg u8 trail_byte;
  reg u64 t;
  reg bool b;

  // intermediate blocks
  while{
    b = inlen >= rate;
  } (b)
  {
    ms = #set_msf(b, ms);
    state, in, inlen, ms = __add_full_block_ref1(state, in, inlen, rate, ms);

    s_in = in;
    s_inlen = inlen;
    s_rate = rate;

    state, ms = _keccakf1600_ref1(state, ms);

    in = s_in;
    in = #protect(in, ms);
    inlen = s_inlen;
    inlen = #protect(inlen, ms);
    rate = s_rate;
    rate = #protect(rate, ms);
  }
  ms = #set_msf(!b, ms);

  // final block
  trail_byte = s_trail_byte;

  state, ms = __add_final_block_ref1(state, in, inlen, trail_byte, rate, ms);

  return state, rate, ms;
}


inline fn __xtr_full_block_ref1(
  reg ptr u64[25] state,
  reg u64 out outlen,
  reg u64 rate,
  #msf reg u64 ms
) -> reg u64, reg u64, #msf reg u64
{
  reg u64 i t rate64;
  reg bool b;

  rate64 = rate;
  rate64 >>= 3;
  i = 0;
  while{
    b = i < rate64;
  } (b)
  {
    ms = #set_msf(b, ms);
    t = state[(int)i];
    [out + 8*i] = t;
    i += 1;
  }
  ms = #set_msf(!b, ms);

  out += rate;
  outlen -= rate;

  return out, outlen, ms;
}


inline fn __xtr_bytes_ref1(
  reg ptr u64[25] state,
  reg u64 out outlen,
  #msf reg u64 ms
) -> reg u64, #msf reg u64
{
  reg u64 i t outlen8;
  reg u8 c;
  reg bool b;

  outlen8 = outlen;
  outlen8 >>= 3;
  i = 0;
  while{
    b = i < outlen8;
  } (b)
  {
    ms = #set_msf(b, ms);
    t = state[(int)i];
    [out + 8*i] = t;
    i += 1;
  }
  ms = #set_msf(!b, ms);
  i <<= 3;

  while{
    b = i < outlen;
  } (b)
  {
    ms = #set_msf(b, ms);
    c = state[u8 (int)i];
    (u8)[out + i] = c;
    i += 1;
  }
  ms = #set_msf(!b, ms);

  out += outlen;
  return out, ms;
}


inline fn __squeeze_ref1(
  reg mut ptr u64[25] state,
  stack   u64 s_out,
  reg     u64 outlen,
  reg     u64 rate,
  #msf reg u64 ms
) -> #msf reg u64
{
  reg u64 out;
  stack u64 s_outlen s_rate;
  reg bool b;

  // intermediate blocks
  while{
    b = outlen > rate;
  } (b)
  {
    ms = #set_msf(b, ms);
    s_outlen = outlen;
    s_rate = rate;

    state, ms = _keccakf1600_ref1(state, ms);

    out = s_out;
    out = #protect(out, ms);
    outlen = s_outlen;
    outlen = #protect(outlen, ms);
    rate = s_rate;
    rate = #protect(rate, ms);

    out, outlen, ms = __xtr_full_block_ref1(state, out, outlen, rate, ms);
    s_out = out;
  }
  ms = #set_msf(!b, ms);

  s_outlen = outlen;

  state, ms = _keccakf1600_ref1(state, ms);

  out = s_out;
  out = #protect(out, ms);
  outlen = s_outlen;
  outlen = #protect(outlen, ms);

  out, ms = __xtr_bytes_ref1(state, out, outlen, ms);
  return ms;
}


inline fn __keccak1600_ref1(reg u64 out outlen in inlen, reg u8 trail_byte, reg u64 rate, #msf reg u64 ms) -> #msf reg u64
{
  stack u64[25] _state;
  reg ptr u64[25] state;
  stack u64 s_out s_outlen;
  stack u8 s_trail_byte;
  reg bool b;

  s_out = out;
  s_outlen = outlen;
  s_trail_byte = trail_byte;

  _state, ms = __keccak_init_ref1(ms);
  state = _state;

  // absorb
  state, rate, ms = __absorb_ref1(state, in, inlen, s_trail_byte, rate, ms);

  // squeeze
  outlen = s_outlen;
  outlen = #protect(outlen, ms);
  ms = __squeeze_ref1(state, s_out, outlen, rate, ms);
  return ms;
}


#[returnaddress="stack"]
fn _keccak1600_ref1(reg u64 out outlen in inlen, reg u8 trail_byte, reg u64 rate, #msf reg u64 ms) -> #msf reg u64
{
  ms = __keccak1600_ref1(out, outlen, in, inlen, trail_byte, rate, ms);
  return ms;
}
